{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"craftr-dsl The Craftr DSL is a transpiler for the Python language that introduces the concept of closures , function calls without parentheses and a few other syntactical sugar into the language. The language is a full superset of Python 3 code. The added syntax features should only be used where it makes the code more readable or where it is semantically more relevant. Installation From Pip: $ pip install craftr-dsl[codegen,colors] Latest from GitHub: $ pip install git+https://github.com/craftr-build/craftr-dsl Requirements: Python 3.8 or newer Hello, World! A convoluted Hello, World! example in Craftr DSL might look like this: # hello.craftr world = { self('World!') } world { print('Hello,', self) } This is transpiled to # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1(self, *arguments, **kwarguments): self('World!') world = _closure_1 def _closure_2(self, *arguments, **kwarguments): print('Hello,', self) world(_closure_2) And evaluates to # $ python -m craftr.dsl hello.craftr Hello, World! Language features The Craftr DSL grammar and code generator can be configured to an extend to turn some language features and semantics on and off. What will be shown below in most examples is compatible with the default configuration unless otherwise noted. Closures Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Craftr DSL Python filter({ self % 2 }, range(5)) def _closure_1(self, *argnames, **kwargnames): self % 2 filter(_closure_1, range(5)) filter(x -> x % 2, range(5)) def _closure_1(x): return x % 2 filter(_closure_1, range(5)) reduce((a, b) -> { a.append(b * 2) return a }, [1, 2, 3], []) def _closure_1(a, b): a.append(b * 2) return a reduce(_closure_1, [1, 2, 3], []) Function calls without parentheses Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Craftr DSL Python print 'Hello, World!', file=sys.stderr print('Hello, World!', file=sys.stderr) map { print('Hello,', self) }, ['John', 'World'] def _closure_1(self, *arguments, **kwarguments): print('Hello,', self) map(_closure_1, ['John', 'World']) Unseparated arguments & colon keyword arguments The Craftr DSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ). Craftr DSL Python print 'Hello, World!' 42 * 1 + 10 file: sys.stdout print('Hello, World!', 42 * 1 + 10, file=sys.stdout) task \"hello_world\" do: { print \"Hello, World!\" } def _closure_1(self, *arguments, **kwarguments): print('Hello, World!') task('hello_world', do=_closure_1) list(map { print('Hello,', self) }, ['John', 'World']) > **Note**: Pitfall, this actually passes three arguments to `list()`. def _closure_1(self, *arguments, **kwarguments): print('Hello,', self) list(map, _closure_1, ['John', 'World']) Dynamic name resolution (non-default) For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object. For this, the Craftr DSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the craftr.dsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from craftr.dsl.transpiler import transpile_to_ast from craftr.dsl.runtime import Closure class Project: def task(self, name: str, *, do: callable): ... code = ... filename = ... # Long form: module = transpile_to_ast(code, filename, Closure.get_options()) code = compile(module, filename, 'exec') scope = {'__closure__': Closure(None, None, Project())} exec(code, scope) # Shorthand form: Closure(None, None, Project()).run_code(code, filename) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.child decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. Craftr DSL Python task \"foobar\" do: { return n_times } task \"belzebub\" do: { def n_times = 1 return n_times } task \"cheeky\" do: { def n_times = 1 return (() -> n_times )() } @__closure__.child def _closure_1(__closure__, self, *arguments, **kwarguments): return __closure__['n_times'] __closure__['task']('foobar', do=_closure_1) @__closure__.child def _closure_2(__closure__, self, *arguments, **kwarguments): n_times = 1 return n_times __closure__['task']('belzebub', do=_closure_2) @__closure__.child def _closure_3(__closure__, self, *arguments, **kwarguments): n_times = 1 @__closure__.child def _closure_3_closure_3(__closure__): return n_times return _closure_3_closure_3() __closure__['task']('cheeky', do=_closure_3) Limitations Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression. Copyright \u00a9 2021 Niklas Rosenstein","title":"Home"},{"location":"#craftr-dsl","text":"The Craftr DSL is a transpiler for the Python language that introduces the concept of closures , function calls without parentheses and a few other syntactical sugar into the language. The language is a full superset of Python 3 code. The added syntax features should only be used where it makes the code more readable or where it is semantically more relevant.","title":"craftr-dsl"},{"location":"#installation","text":"From Pip: $ pip install craftr-dsl[codegen,colors] Latest from GitHub: $ pip install git+https://github.com/craftr-build/craftr-dsl Requirements: Python 3.8 or newer","title":"Installation"},{"location":"#hello-world","text":"A convoluted Hello, World! example in Craftr DSL might look like this: # hello.craftr world = { self('World!') } world { print('Hello,', self) } This is transpiled to # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1(self, *arguments, **kwarguments): self('World!') world = _closure_1 def _closure_2(self, *arguments, **kwarguments): print('Hello,', self) world(_closure_2) And evaluates to # $ python -m craftr.dsl hello.craftr Hello, World!","title":"Hello, World!"},{"location":"#language-features","text":"The Craftr DSL grammar and code generator can be configured to an extend to turn some language features and semantics on and off. What will be shown below in most examples is compatible with the default configuration unless otherwise noted.","title":"Language features"},{"location":"#closures","text":"Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Craftr DSL Python filter({ self % 2 }, range(5)) def _closure_1(self, *argnames, **kwargnames): self % 2 filter(_closure_1, range(5)) filter(x -> x % 2, range(5)) def _closure_1(x): return x % 2 filter(_closure_1, range(5)) reduce((a, b) -> { a.append(b * 2) return a }, [1, 2, 3], []) def _closure_1(a, b): a.append(b * 2) return a reduce(_closure_1, [1, 2, 3], [])","title":"Closures"},{"location":"#function-calls-without-parentheses","text":"Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Craftr DSL Python print 'Hello, World!', file=sys.stderr print('Hello, World!', file=sys.stderr) map { print('Hello,', self) }, ['John', 'World'] def _closure_1(self, *arguments, **kwarguments): print('Hello,', self) map(_closure_1, ['John', 'World'])","title":"Function calls without parentheses"},{"location":"#unseparated-arguments-colon-keyword-arguments","text":"The Craftr DSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ). Craftr DSL Python print 'Hello, World!' 42 * 1 + 10 file: sys.stdout print('Hello, World!', 42 * 1 + 10, file=sys.stdout) task \"hello_world\" do: { print \"Hello, World!\" } def _closure_1(self, *arguments, **kwarguments): print('Hello, World!') task('hello_world', do=_closure_1) list(map { print('Hello,', self) }, ['John', 'World']) > **Note**: Pitfall, this actually passes three arguments to `list()`. def _closure_1(self, *arguments, **kwarguments): print('Hello,', self) list(map, _closure_1, ['John', 'World'])","title":"Unseparated arguments &amp; colon keyword arguments"},{"location":"#dynamic-name-resolution-non-default","text":"For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object. For this, the Craftr DSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the craftr.dsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from craftr.dsl.transpiler import transpile_to_ast from craftr.dsl.runtime import Closure class Project: def task(self, name: str, *, do: callable): ... code = ... filename = ... # Long form: module = transpile_to_ast(code, filename, Closure.get_options()) code = compile(module, filename, 'exec') scope = {'__closure__': Closure(None, None, Project())} exec(code, scope) # Shorthand form: Closure(None, None, Project()).run_code(code, filename) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.child decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. Craftr DSL Python task \"foobar\" do: { return n_times } task \"belzebub\" do: { def n_times = 1 return n_times } task \"cheeky\" do: { def n_times = 1 return (() -> n_times )() } @__closure__.child def _closure_1(__closure__, self, *arguments, **kwarguments): return __closure__['n_times'] __closure__['task']('foobar', do=_closure_1) @__closure__.child def _closure_2(__closure__, self, *arguments, **kwarguments): n_times = 1 return n_times __closure__['task']('belzebub', do=_closure_2) @__closure__.child def _closure_3(__closure__, self, *arguments, **kwarguments): n_times = 1 @__closure__.child def _closure_3_closure_3(__closure__): return n_times return _closure_3_closure_3() __closure__['task']('cheeky', do=_closure_3)","title":"Dynamic name resolution (non-default)"},{"location":"#limitations","text":"Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression. Copyright \u00a9 2021 Niklas Rosenstein","title":"Limitations"},{"location":"changelog/","text":"0.5.0 (2021-09-28) general feature : add craftr.dsl.runtime.ChainContext 0.4.2 (2021-09-28) general fix : fix mypy 0.4.1 (2021-09-28) general fix : add Closure.__setitem__() and Closure.__delitem__() feature : add Closure.run_code() method 0.4.0 (2021-09-28) general change : astor and termcolor are now optional dependencies feature : add Grammar class to configure Rewriter class, add support for colon keyword arguments (enabled by default) feature : add ability to pass function arguments without comma separation (enabled by default) feature : add craftr.dsl.runtime module and TranspileOptions.closure_arglist_prefix fix : fix creation of ast.Subscript node in NameRewriter 0.3.0 (2021-08-28) general change : closures without arguments now have the default argument list (self, *argnames, **kwargnames) instead of (self) 0.1.2 (2021-02-03) general change : Add Runtime.set_property_value() and use that for setting values on Assign statements instead of directly assigning to self","title":"Changelog"},{"location":"changelog/#050-2021-09-28","text":"general feature : add craftr.dsl.runtime.ChainContext","title":"0.5.0 (2021-09-28)"},{"location":"changelog/#042-2021-09-28","text":"general fix : fix mypy","title":"0.4.2 (2021-09-28)"},{"location":"changelog/#041-2021-09-28","text":"general fix : add Closure.__setitem__() and Closure.__delitem__() feature : add Closure.run_code() method","title":"0.4.1 (2021-09-28)"},{"location":"changelog/#040-2021-09-28","text":"general change : astor and termcolor are now optional dependencies feature : add Grammar class to configure Rewriter class, add support for colon keyword arguments (enabled by default) feature : add ability to pass function arguments without comma separation (enabled by default) feature : add craftr.dsl.runtime module and TranspileOptions.closure_arglist_prefix fix : fix creation of ast.Subscript node in NameRewriter","title":"0.4.0 (2021-09-28)"},{"location":"changelog/#030-2021-08-28","text":"general change : closures without arguments now have the default argument list (self, *argnames, **kwargnames) instead of (self)","title":"0.3.0 (2021-08-28)"},{"location":"changelog/#012-2021-02-03","text":"general change : Add Runtime.set_property_value() and use that for setting values on Assign statements instead of directly assigning to self","title":"0.1.2 (2021-02-03)"},{"location":"api-documentation/craftr.dsl/","text":"craftr.dsl This package implements the Craftr DSL laguage.","title":"craftr.dsl"},{"location":"api-documentation/craftr.dsl/#craftrdsl","text":"This package implements the Craftr DSL laguage.","title":"craftr.dsl"},{"location":"api-documentation/craftr.dsl.rewrite/","text":"craftr.dsl.rewrite Rewrite Craftr DSL code to pure Python code. Grammar Objects @dataclass class Grammar() Grammar settings. SyntaxError Objects @dataclass class SyntaxError(Exception) Specialized Craftr DSL syntax error (the internal SyntaxError class is weird). If the termcolor module is installed, the error message will be color coded. RewriteResult Objects @dataclass class RewriteResult() The result of rewriting Craftr DSL code to pure Python code. Rewriter Objects class Rewriter() This class rewrites Craftr DSL code to pure Python code. Closures are extracted from the code and replaced with whitespace where appropriate to keep line and column numbers of the code in tact as much as possible (not always fully accurate). __init__ | __init__(text: str, filename: str, grammar: t.Optional[Grammar] = None) -> None Arguments text : The Craftr DSL code to parse and turn into an AST-like structure. filename : The filename where the DSL code is from. rewrite | rewrite() -> RewriteResult Rewrite the code and return the RewriteResult . This can be interpreted by the craftr.dsl.transpiler.ClosureRewriter to re-inject the code for closures.","title":"craftr.dsl.rewrite"},{"location":"api-documentation/craftr.dsl.rewrite/#craftrdslrewrite","text":"Rewrite Craftr DSL code to pure Python code.","title":"craftr.dsl.rewrite"},{"location":"api-documentation/craftr.dsl.rewrite/#grammar-objects","text":"@dataclass class Grammar() Grammar settings.","title":"Grammar Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#syntaxerror-objects","text":"@dataclass class SyntaxError(Exception) Specialized Craftr DSL syntax error (the internal SyntaxError class is weird). If the termcolor module is installed, the error message will be color coded.","title":"SyntaxError Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#rewriteresult-objects","text":"@dataclass class RewriteResult() The result of rewriting Craftr DSL code to pure Python code.","title":"RewriteResult Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#rewriter-objects","text":"class Rewriter() This class rewrites Craftr DSL code to pure Python code. Closures are extracted from the code and replaced with whitespace where appropriate to keep line and column numbers of the code in tact as much as possible (not always fully accurate).","title":"Rewriter Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#__init__","text":"| __init__(text: str, filename: str, grammar: t.Optional[Grammar] = None) -> None Arguments text : The Craftr DSL code to parse and turn into an AST-like structure. filename : The filename where the DSL code is from.","title":"__init__"},{"location":"api-documentation/craftr.dsl.rewrite/#rewrite","text":"| rewrite() -> RewriteResult Rewrite the code and return the RewriteResult . This can be interpreted by the craftr.dsl.transpiler.ClosureRewriter to re-inject the code for closures.","title":"rewrite"},{"location":"api-documentation/craftr.dsl.runtime/","text":"craftr.dsl.runtime Helpers for added runtime capabilities of transpiled Craftr DSL code, specifically around variable name resolution when enabling TranspileOptions.closure_target . Context Objects class Context(t.Protocol) Protocol for context providers. Context methods are expected to raise a NameError in case of a name resolution error. DefaultContext Objects class DefaultContext(Context) Looks up names that exist in a wrapped object. Only sets or deletes them if they exist, otherwise raises a NameError . It prevents you from overwriting methods. ChainContext Objects class ChainContext(Context) Chain multiple Context implementations. Closure Objects class Closure(Context) run_code | run_code(code: str, filename: str = '<string>', options: t.Optional[TranspileOptions] = None, scope: t.Optional[t.Dict[str, t.Any]] = None) -> None Executes the given Craftr DSL code with the Closure as it's entry __closure__ object.","title":"craftr.dsl.runtime"},{"location":"api-documentation/craftr.dsl.runtime/#craftrdslruntime","text":"Helpers for added runtime capabilities of transpiled Craftr DSL code, specifically around variable name resolution when enabling TranspileOptions.closure_target .","title":"craftr.dsl.runtime"},{"location":"api-documentation/craftr.dsl.runtime/#context-objects","text":"class Context(t.Protocol) Protocol for context providers. Context methods are expected to raise a NameError in case of a name resolution error.","title":"Context Objects"},{"location":"api-documentation/craftr.dsl.runtime/#defaultcontext-objects","text":"class DefaultContext(Context) Looks up names that exist in a wrapped object. Only sets or deletes them if they exist, otherwise raises a NameError . It prevents you from overwriting methods.","title":"DefaultContext Objects"},{"location":"api-documentation/craftr.dsl.runtime/#chaincontext-objects","text":"class ChainContext(Context) Chain multiple Context implementations.","title":"ChainContext Objects"},{"location":"api-documentation/craftr.dsl.runtime/#closure-objects","text":"class Closure(Context)","title":"Closure Objects"},{"location":"api-documentation/craftr.dsl.runtime/#run_code","text":"| run_code(code: str, filename: str = '<string>', options: t.Optional[TranspileOptions] = None, scope: t.Optional[t.Dict[str, t.Any]] = None) -> None Executes the given Craftr DSL code with the Closure as it's entry __closure__ object.","title":"run_code"},{"location":"api-documentation/craftr.dsl.transpiler/","text":"craftr.dsl.transpiler Transpile Craftr DSL code to full fledged Python code. TranspileOptions Objects @dataclass class TranspileOptions() Options for transpiling Craftr DSL code. closure_target If enabled, names are read, written and deleted through the __getitem__() , __setitem__() and __delitem__() of the given name. If you need extra flexibility, you can set this to the name of a global object that is then responsible for name resolution. pure_builtins Set of builtin names that are \"pure\", i.e. they are never touched by the NameRerwriter . This is only used if closure_target is set. local_vardef_prefix This is only used if closure_target is specified and the NameRewriter kicks in. Variable declarations prefixed with def are prefixed with the given string. preamble A preamble of pure Python code to include at the top of the module. closure_def_prefix Pure python code to include before a closure definition, for example to decorate it. closure_default_arglist The default argument list for closures without an explicit argument list. By default a closure always accepts a \"self\" argument, but also any other arguments that are passed to it. This is useful when using a arglist-less closure for a function that passed multiple arguments, but the closure is only interested in the first. closure_arglist_prefix A prefix to the argument list of closures. This prefix is added even to closures without explicit arglist (so the final arglist will be closure_arglist_prefix followed by closure_default_arglist ). transpile_to_ast transpile_to_ast(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> ast.Module Transpile the Craftr DSL code to a Python ast.Module that can be executed. transpile_to_source transpile_to_source(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> str Transpile the Craftr DSL code to Python code. Requires the astor module to be installed. ClosureRewriter Objects class ClosureRewriter(ast.NodeTransformer) Rewrites references to closure variables and injects Closure function definitions. NameRewriter Objects class NameRewriter(ast.NodeTransformer) Rewrites names be accessed through a global object.","title":"craftr.dsl.transpiler"},{"location":"api-documentation/craftr.dsl.transpiler/#craftrdsltranspiler","text":"Transpile Craftr DSL code to full fledged Python code.","title":"craftr.dsl.transpiler"},{"location":"api-documentation/craftr.dsl.transpiler/#transpileoptions-objects","text":"@dataclass class TranspileOptions() Options for transpiling Craftr DSL code.","title":"TranspileOptions Objects"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_target","text":"If enabled, names are read, written and deleted through the __getitem__() , __setitem__() and __delitem__() of the given name. If you need extra flexibility, you can set this to the name of a global object that is then responsible for name resolution.","title":"closure_target"},{"location":"api-documentation/craftr.dsl.transpiler/#pure_builtins","text":"Set of builtin names that are \"pure\", i.e. they are never touched by the NameRerwriter . This is only used if closure_target is set.","title":"pure_builtins"},{"location":"api-documentation/craftr.dsl.transpiler/#local_vardef_prefix","text":"This is only used if closure_target is specified and the NameRewriter kicks in. Variable declarations prefixed with def are prefixed with the given string.","title":"local_vardef_prefix"},{"location":"api-documentation/craftr.dsl.transpiler/#preamble","text":"A preamble of pure Python code to include at the top of the module.","title":"preamble"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_def_prefix","text":"Pure python code to include before a closure definition, for example to decorate it.","title":"closure_def_prefix"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_default_arglist","text":"The default argument list for closures without an explicit argument list. By default a closure always accepts a \"self\" argument, but also any other arguments that are passed to it. This is useful when using a arglist-less closure for a function that passed multiple arguments, but the closure is only interested in the first.","title":"closure_default_arglist"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_arglist_prefix","text":"A prefix to the argument list of closures. This prefix is added even to closures without explicit arglist (so the final arglist will be closure_arglist_prefix followed by closure_default_arglist ).","title":"closure_arglist_prefix"},{"location":"api-documentation/craftr.dsl.transpiler/#transpile_to_ast","text":"transpile_to_ast(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> ast.Module Transpile the Craftr DSL code to a Python ast.Module that can be executed.","title":"transpile_to_ast"},{"location":"api-documentation/craftr.dsl.transpiler/#transpile_to_source","text":"transpile_to_source(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> str Transpile the Craftr DSL code to Python code. Requires the astor module to be installed.","title":"transpile_to_source"},{"location":"api-documentation/craftr.dsl.transpiler/#closurerewriter-objects","text":"class ClosureRewriter(ast.NodeTransformer) Rewrites references to closure variables and injects Closure function definitions.","title":"ClosureRewriter Objects"},{"location":"api-documentation/craftr.dsl.transpiler/#namerewriter-objects","text":"class NameRewriter(ast.NodeTransformer) Rewrites names be accessed through a global object.","title":"NameRewriter Objects"}]}