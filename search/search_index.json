{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Craftr DSL documentation! A domain specific language purpose-built for the Craftr build system. The Craftr DSL is an \"almost superset\" of Python 3; adding a lot of syntactical features that make it more convenient to describe build configurations at the cost of some other syntax features of the native Python language (like set literals). Installation $ pip install craftr-dsl The craftr-dsl package requires at least Python 3.8. Projects using Craftr DSL Novella","title":"Home"},{"location":"#welcome-to-the-craftr-dsl-documentation","text":"A domain specific language purpose-built for the Craftr build system. The Craftr DSL is an \"almost superset\" of Python 3; adding a lot of syntactical features that make it more convenient to describe build configurations at the cost of some other syntax features of the native Python language (like set literals).","title":"Welcome to the Craftr DSL documentation!"},{"location":"#installation","text":"$ pip install craftr-dsl The craftr-dsl package requires at least Python 3.8.","title":"Installation"},{"location":"#projects-using-craftr-dsl","text":"Novella","title":"Projects using Craftr DSL"},{"location":"changelog/","text":"Changelog Unreleased Type Description PR Issues Author Improvement Make `astor` dependency an extra called \"astor\", it is required only for `transpile_to_source()` @NiklasRosenstein 0.8.0 (2022-04-13) Type Description PR Issues Author Feature support Python 3.7 @NiklasRosenstein 0.7.7 (2022-02-27) Type Description PR Issues Author Improvement support Python 3.8+ (before was 3.10) @NiklasRosenstein 0.7.6 (2022-02-27) Type Description PR Issues Author Fix support walrus operator (`:=`) craftr-build/craftr-dsl#5 @NiklasRosenstein 0.7.5 (2022-02-27) Type Description PR Issues Author Fix support more assignment operators like `+=`, `-=`, etc. as well as `and` and `or` binary operators 7 @NiklasRosenstein","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"Type Description PR Issues Author Improvement Make `astor` dependency an extra called \"astor\", it is required only for `transpile_to_source()` @NiklasRosenstein","title":"Unreleased"},{"location":"changelog/#080-2022-04-13","text":"Type Description PR Issues Author Feature support Python 3.7 @NiklasRosenstein","title":"0.8.0 (2022-04-13)"},{"location":"changelog/#077-2022-02-27","text":"Type Description PR Issues Author Improvement support Python 3.8+ (before was 3.10) @NiklasRosenstein","title":"0.7.7 (2022-02-27)"},{"location":"changelog/#076-2022-02-27","text":"Type Description PR Issues Author Fix support walrus operator (`:=`) craftr-build/craftr-dsl#5 @NiklasRosenstein","title":"0.7.6 (2022-02-27)"},{"location":"changelog/#075-2022-02-27","text":"Type Description PR Issues Author Fix support more assignment operators like `+=`, `-=`, etc. as well as `and` and `or` binary operators 7 @NiklasRosenstein","title":"0.7.5 (2022-02-27)"},{"location":"introduction/","text":"Introduction Craftr DSL is a Python superset language inspired by Gradle. It was designed for as the main configuration language for the Craftr build system . Albeit as of writing this (Feb 27, 2022), the Craftr build system itself is not mature, the DSL is relatively stable. It introduces additional syntactic constructs into the language, such as paren-less function calls, colon keyword arguments, paren-less line-spanning statements without newline escaping and multi-line lambdas (called \"closures\"). Optionally, a feature can be enabled to allow for dynamic variable name resolution which allows for a concise syntax that does not require prefixing members of the closure target with self . Example This might be a bit of a convoluted way to print \"Hello, World\", but it shows well how closures in Craftr DSL work: # hello.craftr world = { self ( 'World!' ) } world { print ( 'Hello,' , self ) } This transpiles to Standard Dynamic name resolution # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1 ( self , * arguments , ** kwarguments ): self ( 'World!' ) world = _closure_1 def _closure_2 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) world ( _closure_2 ) # $ python -m craftr.dsl hello.craftr -E -C | grep -v -e '^$' @__closure__ . child def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): self ( 'World!' ) __closure__ [ 'world' ] = _closure_1 @__closure__ . child def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): __closure__ [ 'print' ]( 'Hello,' , self ) __closure__ [ 'world' ]( _closure_2 ) And evaluates to # $ python -m craftr.dsl hello.craftr Hello , World ! Note Craftr DSL is not usually designed to be used for standalone scripts, but usually as a configuration language for other systems. It is therefore uncommon to run any production code through python -m craftr.dsl . Code transpiled using dynamic name resolution requires a root closure to be supplied as well, which is not possible via the command-line. However, the command-line interface is very useful to run quick tests and to inspect what the transpiled version of the code looks like.","title":"Introduction"},{"location":"introduction/#introduction","text":"Craftr DSL is a Python superset language inspired by Gradle. It was designed for as the main configuration language for the Craftr build system . Albeit as of writing this (Feb 27, 2022), the Craftr build system itself is not mature, the DSL is relatively stable. It introduces additional syntactic constructs into the language, such as paren-less function calls, colon keyword arguments, paren-less line-spanning statements without newline escaping and multi-line lambdas (called \"closures\"). Optionally, a feature can be enabled to allow for dynamic variable name resolution which allows for a concise syntax that does not require prefixing members of the closure target with self .","title":"Introduction"},{"location":"introduction/#example","text":"This might be a bit of a convoluted way to print \"Hello, World\", but it shows well how closures in Craftr DSL work: # hello.craftr world = { self ( 'World!' ) } world { print ( 'Hello,' , self ) } This transpiles to Standard Dynamic name resolution # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1 ( self , * arguments , ** kwarguments ): self ( 'World!' ) world = _closure_1 def _closure_2 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) world ( _closure_2 ) # $ python -m craftr.dsl hello.craftr -E -C | grep -v -e '^$' @__closure__ . child def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): self ( 'World!' ) __closure__ [ 'world' ] = _closure_1 @__closure__ . child def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): __closure__ [ 'print' ]( 'Hello,' , self ) __closure__ [ 'world' ]( _closure_2 ) And evaluates to # $ python -m craftr.dsl hello.craftr Hello , World ! Note Craftr DSL is not usually designed to be used for standalone scripts, but usually as a configuration language for other systems. It is therefore uncommon to run any production code through python -m craftr.dsl . Code transpiled using dynamic name resolution requires a root closure to be supplied as well, which is not possible via the command-line. However, the command-line interface is very useful to run quick tests and to inspect what the transpiled version of the code looks like.","title":"Example"},{"location":"api/cli/","text":"Command-line usage: python -m craftr.dsl [-h] [-c ENTRYPOINT] [-E] [-C] [file] positional arguments: file options: -h, --help show this help message and exit -c ENTRYPOINT, --context ENTRYPOINT -E, --transpile -C, --enable-closures","title":"Command-line"},{"location":"api/cli/#command-line","text":"usage: python -m craftr.dsl [-h] [-c ENTRYPOINT] [-E] [-C] [file] positional arguments: file options: -h, --help show this help message and exit -c ENTRYPOINT, --context ENTRYPOINT -E, --transpile -C, --enable-closures","title":"Command-line"},{"location":"api/docs/","text":"Documentation @pydoc craftr.dsl.execute @pydoc craftr.dsl.Grammar @pydoc craftr.dsl.SyntaxError @pydoc craftr.dsl.ChainContext @pydoc craftr.dsl.Closure @pydoc craftr.dsl.Context @pydoc craftr.dsl.MapContext @pydoc craftr.dsl.ObjectContext @pydoc craftr.dsl.TranspileOptions @pydoc craftr.dsl.transpile_to_ast @pydoc craftr.dsl.transpile_to_source","title":"Documentation"},{"location":"api/docs/#documentation","text":"@pydoc craftr.dsl.execute @pydoc craftr.dsl.Grammar @pydoc craftr.dsl.SyntaxError @pydoc craftr.dsl.ChainContext @pydoc craftr.dsl.Closure @pydoc craftr.dsl.Context @pydoc craftr.dsl.MapContext @pydoc craftr.dsl.ObjectContext @pydoc craftr.dsl.TranspileOptions @pydoc craftr.dsl.transpile_to_ast @pydoc craftr.dsl.transpile_to_source","title":"Documentation"},{"location":"api/usage-example/","text":"Usage example This example is from the Novella project. It uses the craftr.dsl.Closure class to execute a file that contains Craftr DSL code using a NovellaContext object as the root closure target. This allows members of the target object to be invoked at the top-level of the script directly without explicitly prefixing the member names with self or any of the sort. class Novella : \"\"\" This class is the main entrypoint for starting and controlling a Novella build. \"\"\" BUILD_FILE = Path ( 'build.novella' ) def __init__ ( self , project_directory : Path ) -> None : self . project_directory = project_directory def execute_file ( self , file : Path | None = None ) -> NovellaContext : \"\"\" Execute a file, allowing it to populate the Novella pipeline. \"\"\" from craftr.dsl import Closure context = NovellaContext ( self ) file = file or self . BUILD_FILE Closure ( None , None , context ) . run_code ( file . read_text (), str ( file )) return context class NovellaContext : def do ( self , action_type_name : str , closure : t . Callable | None = None , name : str | None = None , ) -> None : # ... Example script do \"copy-files\" { content = [ \"content\" , \"mkdocs.yml\" ] }","title":"Usage example"},{"location":"api/usage-example/#usage-example","text":"This example is from the Novella project. It uses the craftr.dsl.Closure class to execute a file that contains Craftr DSL code using a NovellaContext object as the root closure target. This allows members of the target object to be invoked at the top-level of the script directly without explicitly prefixing the member names with self or any of the sort. class Novella : \"\"\" This class is the main entrypoint for starting and controlling a Novella build. \"\"\" BUILD_FILE = Path ( 'build.novella' ) def __init__ ( self , project_directory : Path ) -> None : self . project_directory = project_directory def execute_file ( self , file : Path | None = None ) -> NovellaContext : \"\"\" Execute a file, allowing it to populate the Novella pipeline. \"\"\" from craftr.dsl import Closure context = NovellaContext ( self ) file = file or self . BUILD_FILE Closure ( None , None , context ) . run_code ( file . read_text (), str ( file )) return context class NovellaContext : def do ( self , action_type_name : str , closure : t . Callable | None = None , name : str | None = None , ) -> None : # ... Example script do \"copy-files\" { content = [ \"content\" , \"mkdocs.yml\" ] }","title":"Usage example"},{"location":"syntax/closures/","text":"Closures Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Example 1 Craftr DSL Python filter ({ self % 2 }, range ( 5 )) def _closure_1 ( self , * argnames , ** kwargnames ): self % 2 filter ( _closure_1 , range ( 5 )) Example 2 Craftr DSL Python filter ( x -> x % 2 , range ( 5 )) def _closure_1 ( x ): return x % 2 filter ( _closure_1 , range ( 5 )) Example 3 Craftr DSL Python reduce (( a , b ) -> { a . append ( b * 2 ) return a }, [ 1 , 2 , 3 ], []) def _closure_1 ( a , b ): a . append ( b * 2 ) return a reduce ( _closure_1 , [ 1 , 2 , 3 ], [])","title":"Closures"},{"location":"syntax/closures/#closures","text":"Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) .","title":"Closures"},{"location":"syntax/closures/#example-1","text":"Craftr DSL Python filter ({ self % 2 }, range ( 5 )) def _closure_1 ( self , * argnames , ** kwargnames ): self % 2 filter ( _closure_1 , range ( 5 ))","title":"Example 1"},{"location":"syntax/closures/#example-2","text":"Craftr DSL Python filter ( x -> x % 2 , range ( 5 )) def _closure_1 ( x ): return x % 2 filter ( _closure_1 , range ( 5 ))","title":"Example 2"},{"location":"syntax/closures/#example-3","text":"Craftr DSL Python reduce (( a , b ) -> { a . append ( b * 2 ) return a }, [ 1 , 2 , 3 ], []) def _closure_1 ( a , b ): a . append ( b * 2 ) return a reduce ( _closure_1 , [ 1 , 2 , 3 ], [])","title":"Example 3"},{"location":"syntax/function-args/","text":"Unseparated arguments & colon keyword arguments The Craftr DSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ). Example 1 Craftr DSL Python print 'Hello, World!' 42 * 1 + 10 file : sys . stdout print ( 'Hello, World!' , 42 * 1 + 10 , file = sys . stdout ) Example 2 Craftr DSL Python task \"hello_world\" do : { print \"Hello, World!\" } def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello, World!' ) task ( 'hello_world' , do = _closure_1 ) Example 3 Craftr DSL Python list ( map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ]) def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) list ( map , _closure_1 , [ 'John' , 'World' ]) Note : Pitfall, this actually passes three arguments to list() .","title":"Unseparated arguments & colon keyword arguments"},{"location":"syntax/function-args/#unseparated-arguments-colon-keyword-arguments","text":"The Craftr DSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ).","title":"Unseparated arguments &amp; colon keyword arguments"},{"location":"syntax/function-args/#example-1","text":"Craftr DSL Python print 'Hello, World!' 42 * 1 + 10 file : sys . stdout print ( 'Hello, World!' , 42 * 1 + 10 , file = sys . stdout )","title":"Example 1"},{"location":"syntax/function-args/#example-2","text":"Craftr DSL Python task \"hello_world\" do : { print \"Hello, World!\" } def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello, World!' ) task ( 'hello_world' , do = _closure_1 )","title":"Example 2"},{"location":"syntax/function-args/#example-3","text":"Craftr DSL Python list ( map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ]) def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) list ( map , _closure_1 , [ 'John' , 'World' ]) Note : Pitfall, this actually passes three arguments to list() .","title":"Example 3"},{"location":"syntax/function-calls/","text":"Function calls without parentheses Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Example 1 Craftr DSL Python print 'Hello, World!' , file = sys . stderr print ( 'Hello, World!' , file = sys . stderr ) Example 2 Craftr DSL Python map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ] def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) map ( _closure_1 , [ 'John' , 'World' ])","title":"Function calls without parentheses"},{"location":"syntax/function-calls/#function-calls-without-parentheses","text":"Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported.","title":"Function calls without parentheses"},{"location":"syntax/function-calls/#example-1","text":"Craftr DSL Python print 'Hello, World!' , file = sys . stderr print ( 'Hello, World!' , file = sys . stderr )","title":"Example 1"},{"location":"syntax/function-calls/#example-2","text":"Craftr DSL Python map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ] def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) map ( _closure_1 , [ 'John' , 'World' ])","title":"Example 2"},{"location":"syntax/limitations/","text":"Limitations Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression.","title":"Limitations"},{"location":"syntax/limitations/#limitations","text":"Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression.","title":"Limitations"},{"location":"syntax/name-resolution/","text":"Dynamic name resolution (non-default) For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object is too cumbersome. For this, the Craftr DSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the craftr.dsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from craftr.dsl.transpiler import transpile_to_ast from craftr.dsl.runtime import Closure class Project : def task ( self , name : str , * , do : callable ): ... code = ... filename = ... # Long form: module = transpile_to_ast ( code , filename , Closure . get_options ()) code = compile ( module , filename , 'exec' ) scope = { '__closure__' : Closure ( None , None , Project ())} exec ( code , scope ) # Shorthand form: Closure ( None , None , Project ()) . run_code ( code , filename ) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.child decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. Craftr DSL Python task \"foobar\" do : { return n_times } task \"belzebub\" do : { def n_times = 1 return n_times } task \"cheeky\" do : { def n_times = 1 return (() -> n_times )() } @__closure__ . child def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): return __closure__ [ 'n_times' ] __closure__ [ 'task' ]( 'foobar' , do = _closure_1 ) @__closure__ . child def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 return n_times __closure__ [ 'task' ]( 'belzebub' , do = _closure_2 ) @__closure__ . child def _closure_3 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 @__closure__ . child def _closure_3_closure_3 ( __closure__ ): return n_times return _closure_3_closure_3 () __closure__ [ 'task' ]( 'cheeky' , do = _closure_3 )","title":"Dynamic name resolution <sup>(non-default)</sup>"},{"location":"syntax/name-resolution/#dynamic-name-resolution-non-default","text":"For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object is too cumbersome. For this, the Craftr DSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the craftr.dsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from craftr.dsl.transpiler import transpile_to_ast from craftr.dsl.runtime import Closure class Project : def task ( self , name : str , * , do : callable ): ... code = ... filename = ... # Long form: module = transpile_to_ast ( code , filename , Closure . get_options ()) code = compile ( module , filename , 'exec' ) scope = { '__closure__' : Closure ( None , None , Project ())} exec ( code , scope ) # Shorthand form: Closure ( None , None , Project ()) . run_code ( code , filename ) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.child decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. Craftr DSL Python task \"foobar\" do : { return n_times } task \"belzebub\" do : { def n_times = 1 return n_times } task \"cheeky\" do : { def n_times = 1 return (() -> n_times )() } @__closure__ . child def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): return __closure__ [ 'n_times' ] __closure__ [ 'task' ]( 'foobar' , do = _closure_1 ) @__closure__ . child def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 return n_times __closure__ [ 'task' ]( 'belzebub' , do = _closure_2 ) @__closure__ . child def _closure_3 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 @__closure__ . child def _closure_3_closure_3 ( __closure__ ): return n_times return _closure_3_closure_3 () __closure__ [ 'task' ]( 'cheeky' , do = _closure_3 )","title":"Dynamic name resolution (non-default)"}]}