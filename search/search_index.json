{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"craftr-dsl The Craftr DSL is a transpiler for the Python language that introduces the concept of closures an function calls without parentheses into the language. Getting started Installation From Pip: $ pip install craftr-dsl[source,colors] Latest from GitHub: $ pip install git+https://github.com/craftr-build/craftr-dsl Requirements: Python 3.8 or newer Hello, World! A convoluted Hello, World! example in Craftr DSL might look like this: # hello.craftr world = { self('World!') } world { print('Hello,', self) } This is transpiled to # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1(self, *arguments, **kwarguments): self('World!') world = _closure_1 def _closure_2(self, *arguments, **kwarguments): print('Hello,', self) world(_closure_2) And evaluates to # $ python -m craftr.dsl hello.craftr Hello, World! Language features Closures Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Craftr DSL Python filter({ self % 2 }, range(5)) def _closure_1(self, *argnames, **kwargnames): self % 2 filter(_closure_1, range(5)) filter(x -> x % 2, range(5)) def _closure_1(x): return x % 2 filter(_closure_1, range(5)) reduce((a, b) -> { a.append(b * 2) return a }, [1, 2, 3], []) def _closure_1(a, b): a.append(b * 2) return a reduce(_closure_1, [1, 2, 3], []) Function calls without parentheses Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Craftr DSL Python print 'Hello, World!', file=sys.stderr print('Hello, World!', file=sys.stderr) map { print('Hello,', self) }, ['John', 'World'] def _closure_1(self): print('Hello,', self) map(_closure_1, ['John', 'World']) list(map { # Not allowed inside an expression print('Hello,', self) }, ['John', 'World']) craftr.dsl.rewrite.SyntaxError: in <stdin> at line 1: expected ) but got TokenProxy(Token(type=<Token.Control: 8>, value='{', pos=Cursor(offset=9, line=1, column=9))) |list(map { |~~~~~~~~~^ Limitations Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Copyright \u00a9 2021 Niklas Rosenstein","title":"Home"},{"location":"#craftr-dsl","text":"The Craftr DSL is a transpiler for the Python language that introduces the concept of closures an function calls without parentheses into the language.","title":"craftr-dsl"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"From Pip: $ pip install craftr-dsl[source,colors] Latest from GitHub: $ pip install git+https://github.com/craftr-build/craftr-dsl Requirements: Python 3.8 or newer","title":"Installation"},{"location":"#hello-world","text":"A convoluted Hello, World! example in Craftr DSL might look like this: # hello.craftr world = { self('World!') } world { print('Hello,', self) } This is transpiled to # $ python -m craftr.dsl hello.craftr -E | grep -v -e '^$' def _closure_1(self, *arguments, **kwarguments): self('World!') world = _closure_1 def _closure_2(self, *arguments, **kwarguments): print('Hello,', self) world(_closure_2) And evaluates to # $ python -m craftr.dsl hello.craftr Hello, World!","title":"Hello, World!"},{"location":"#language-features","text":"","title":"Language features"},{"location":"#closures","text":"Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Craftr DSL Python filter({ self % 2 }, range(5)) def _closure_1(self, *argnames, **kwargnames): self % 2 filter(_closure_1, range(5)) filter(x -> x % 2, range(5)) def _closure_1(x): return x % 2 filter(_closure_1, range(5)) reduce((a, b) -> { a.append(b * 2) return a }, [1, 2, 3], []) def _closure_1(a, b): a.append(b * 2) return a reduce(_closure_1, [1, 2, 3], [])","title":"Closures"},{"location":"#function-calls-without-parentheses","text":"Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Craftr DSL Python print 'Hello, World!', file=sys.stderr print('Hello, World!', file=sys.stderr) map { print('Hello,', self) }, ['John', 'World'] def _closure_1(self): print('Hello,', self) map(_closure_1, ['John', 'World']) list(map { # Not allowed inside an expression print('Hello,', self) }, ['John', 'World']) craftr.dsl.rewrite.SyntaxError: in <stdin> at line 1: expected ) but got TokenProxy(Token(type=<Token.Control: 8>, value='{', pos=Cursor(offset=9, line=1, column=9))) |list(map { |~~~~~~~~~^","title":"Function calls without parentheses"},{"location":"#limitations","text":"Craftr DSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Copyright \u00a9 2021 Niklas Rosenstein","title":"Limitations"},{"location":"changelog/","text":"Unreleased (no release date) general change : astor and termcolor are now optional dependencies feature : add Grammar class to configure Rewriter class, add support for colon keyword arguments (enabled by default) feature : add ability to pass function arguments without comma separation (enabled by default) 0.3.0 (2021-08-28) general change : closures without arguments now have the default argument list (self, *argnames, **kwargnames) instead of (self) 0.1.2 (2021-02-03) general change : Add Runtime.set_property_value() and use that for setting values on Assign statements instead of directly assigning to self","title":"Changelog"},{"location":"changelog/#unreleased-no-release-date","text":"general change : astor and termcolor are now optional dependencies feature : add Grammar class to configure Rewriter class, add support for colon keyword arguments (enabled by default) feature : add ability to pass function arguments without comma separation (enabled by default)","title":"Unreleased (no release date)"},{"location":"changelog/#030-2021-08-28","text":"general change : closures without arguments now have the default argument list (self, *argnames, **kwargnames) instead of (self)","title":"0.3.0 (2021-08-28)"},{"location":"changelog/#012-2021-02-03","text":"general change : Add Runtime.set_property_value() and use that for setting values on Assign statements instead of directly assigning to self","title":"0.1.2 (2021-02-03)"},{"location":"api-documentation/craftr.dsl/","text":"craftr.dsl This package implements the Craftr DSL laguage.","title":"craftr.dsl"},{"location":"api-documentation/craftr.dsl/#craftrdsl","text":"This package implements the Craftr DSL laguage.","title":"craftr.dsl"},{"location":"api-documentation/craftr.dsl.rewrite/","text":"craftr.dsl.rewrite Rewrite Craftr DSL code to pure Python code. SyntaxError Objects @dataclass class SyntaxError(Exception) Specialized Craftr DSL syntax error (the internal SyntaxError class is weird). If the termcolor module is installed, the error message will be color coded. RewriteResult Objects @dataclass class RewriteResult() The result of rewriting Craftr DSL code to pure Python code. Rewriter Objects class Rewriter() This class rewrites Craftr DSL code to pure Python code. Closures are extracted from the code and replaced with whitespace where appropriate to keep line and column numbers of the code in tact as much as possible (not always fully accurate). __init__ | __init__(text: str, filename: str, grammar: t.Optional[Grammar] = None) -> None Arguments text : The Craftr DSL code to parse and turn into an AST-like structure. filename : The filename where the DSL code is from. rewrite | rewrite() -> RewriteResult Rewrite the code and return the RewriteResult . This can be interpreted by the craftr.dsl.transpiler.ClosureRewriter to re-inject the code for closures.","title":"craftr.dsl.rewrite"},{"location":"api-documentation/craftr.dsl.rewrite/#craftrdslrewrite","text":"Rewrite Craftr DSL code to pure Python code.","title":"craftr.dsl.rewrite"},{"location":"api-documentation/craftr.dsl.rewrite/#syntaxerror-objects","text":"@dataclass class SyntaxError(Exception) Specialized Craftr DSL syntax error (the internal SyntaxError class is weird). If the termcolor module is installed, the error message will be color coded.","title":"SyntaxError Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#rewriteresult-objects","text":"@dataclass class RewriteResult() The result of rewriting Craftr DSL code to pure Python code.","title":"RewriteResult Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#rewriter-objects","text":"class Rewriter() This class rewrites Craftr DSL code to pure Python code. Closures are extracted from the code and replaced with whitespace where appropriate to keep line and column numbers of the code in tact as much as possible (not always fully accurate).","title":"Rewriter Objects"},{"location":"api-documentation/craftr.dsl.rewrite/#__init__","text":"| __init__(text: str, filename: str, grammar: t.Optional[Grammar] = None) -> None Arguments text : The Craftr DSL code to parse and turn into an AST-like structure. filename : The filename where the DSL code is from.","title":"__init__"},{"location":"api-documentation/craftr.dsl.rewrite/#rewrite","text":"| rewrite() -> RewriteResult Rewrite the code and return the RewriteResult . This can be interpreted by the craftr.dsl.transpiler.ClosureRewriter to re-inject the code for closures.","title":"rewrite"},{"location":"api-documentation/craftr.dsl.transpiler/","text":"craftr.dsl.transpiler Transpile Craftr DSL code to full fledged Python code. TranspileOptions Objects @dataclass class TranspileOptions() Options for transpiling Craftr DSL code. closure_target If enabled, names are read, written and deleted through the __getitem__() , __setitem__() and __delitem__() of the given name. If you need extra flexibility, you can set this to the name of a global object that is then responsible for name resolution. pure_builtins Set of builtin names that are \"pure\", i.e. they are never touched by the NameRerwriter . This is only used if closure_target is set. local_vardef_prefix This is only used if closure_target is specified and the NameRewriter kicks in. Variable declarations prefixed with def are prefixed with the given string. preamble A preamble of pure Python code to include at the top of the module. closure_def_prefix Pure python code to include before a closure definition, for example to decorate it. closure_default_arglist The default argument list for closures without an explicit argument list. By default a closure always accepts a \"self\" argument, but also any other arguments that are passed to it. This is useful when using a arglist-less closure for a function that passed multiple arguments, but the closure is only interested in the first. transpile_to_ast transpile_to_ast(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> ast.Module Transpile the Craftr DSL code to a Python ast.Module that can be executed. transpile_to_source transpile_to_source(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> str Transpile the Craftr DSL code to Python code. Requires the astor module to be installed. ClosureRewriter Objects class ClosureRewriter(ast.NodeTransformer) Rewrites references to closure variables and injects Closure function definitions. NameRewriter Objects class NameRewriter(ast.NodeTransformer) Rewrites names be accessed through a global object.","title":"craftr.dsl.transpiler"},{"location":"api-documentation/craftr.dsl.transpiler/#craftrdsltranspiler","text":"Transpile Craftr DSL code to full fledged Python code.","title":"craftr.dsl.transpiler"},{"location":"api-documentation/craftr.dsl.transpiler/#transpileoptions-objects","text":"@dataclass class TranspileOptions() Options for transpiling Craftr DSL code.","title":"TranspileOptions Objects"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_target","text":"If enabled, names are read, written and deleted through the __getitem__() , __setitem__() and __delitem__() of the given name. If you need extra flexibility, you can set this to the name of a global object that is then responsible for name resolution.","title":"closure_target"},{"location":"api-documentation/craftr.dsl.transpiler/#pure_builtins","text":"Set of builtin names that are \"pure\", i.e. they are never touched by the NameRerwriter . This is only used if closure_target is set.","title":"pure_builtins"},{"location":"api-documentation/craftr.dsl.transpiler/#local_vardef_prefix","text":"This is only used if closure_target is specified and the NameRewriter kicks in. Variable declarations prefixed with def are prefixed with the given string.","title":"local_vardef_prefix"},{"location":"api-documentation/craftr.dsl.transpiler/#preamble","text":"A preamble of pure Python code to include at the top of the module.","title":"preamble"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_def_prefix","text":"Pure python code to include before a closure definition, for example to decorate it.","title":"closure_def_prefix"},{"location":"api-documentation/craftr.dsl.transpiler/#closure_default_arglist","text":"The default argument list for closures without an explicit argument list. By default a closure always accepts a \"self\" argument, but also any other arguments that are passed to it. This is useful when using a arglist-less closure for a function that passed multiple arguments, but the closure is only interested in the first.","title":"closure_default_arglist"},{"location":"api-documentation/craftr.dsl.transpiler/#transpile_to_ast","text":"transpile_to_ast(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> ast.Module Transpile the Craftr DSL code to a Python ast.Module that can be executed.","title":"transpile_to_ast"},{"location":"api-documentation/craftr.dsl.transpiler/#transpile_to_source","text":"transpile_to_source(code: str, filename: str, options: t.Optional[TranspileOptions] = None) -> str Transpile the Craftr DSL code to Python code. Requires the astor module to be installed.","title":"transpile_to_source"},{"location":"api-documentation/craftr.dsl.transpiler/#closurerewriter-objects","text":"class ClosureRewriter(ast.NodeTransformer) Rewrites references to closure variables and injects Closure function definitions.","title":"ClosureRewriter Objects"},{"location":"api-documentation/craftr.dsl.transpiler/#namerewriter-objects","text":"class NameRewriter(ast.NodeTransformer) Rewrites names be accessed through a global object.","title":"NameRewriter Objects"}]}